NarrativeSignRestrictions <- function(sign.restrictions,posterior,narrative.restrictions,Y,X){
# posterior -   a list - estimation outcome from function Posterior
A.posterior   = posterior$A.posterior
B.posterior = posterior$B.posterior
B1.posterior = posterior$B1.posterior
Sigma.posterior = posterior$Sigma.posterior
YY = Y
XX = X
S = dim(A.posterior)[3]
N = dim(B.posterior)[1]
p = (dim(B1.posterior)[2]-1)/N
R1            = diag(sign.restrictions)
B0.draws      = array(NA,c(N,N,S))
B1.draws      = array(NA,c(N,(1+N*p),S))
pb = txtProgressBar(min = 0, max = S, initial = 0)
for (s in 1:S){
setTxtProgressBar(pb, s)
B0.tilde <-B.posterior[,,s]
B1.tilde <-  B1.posterior[,,s]
A <- A.posterior[,,s]
Sigma <- Sigma.posterior[,,s]
sign.restrictions.do.not.hold = TRUE
narrative.restriction.do.not.hold = TRUE
i=1
while (sign.restrictions.do.not.hold){
X           = matrix(rnorm(N*N),N,N)
QR          = qr(X, tol = 1e-10)
Q           = qr.Q(QR,complete=TRUE)
R           = qr.R(QR,complete=TRUE)
Q           = t(Q %*% diag(sign(diag(R))))
B0          = Q%*%B0.tilde
B0.inv      = solve(B0)
B1          = Q%*%B1.tilde
u = YY %*% t(B0) - XX %*% t(B1)
u= u[,1]
check       = prod(R1 %*% B0.inv %*% diag(N)[,1] > 0  ) # Check reponse at time 0
check_narrative = prod(sign(u[narrative.restrictions]) > 0)
if (check == 1 && check_narrative == 1) {
sign.restrictions.do.not.hold = FALSE
}
i = i + 1
B0.draws[, , s] = B0
B1.draws[, , s] = B1
}
close(pb)
}
return (list(B0.draws = B0.draws,
B1.draws = B1.draws,
i        = i))
}
### Proof that your model can replicate the true parameters of the data-generating process.
# Set parameters
n_obs = 1000
p <- 1
N <- 2
S <- 50000
# 1. Generate artificial data
set.seed(2023) # for reproducibility
cov_matrix <- diag(N)
mean_vector <- rep(0, N)
# Simulate bi-variate Gaussian random walk
RW1 <- arima.sim(model= list(order = c(0, 1, 0)), n=1000, mean=0, sd=1)
RW2 <- arima.sim(model= list(order = c(0, 1, 0)), n=1000, mean=0, sd=1)
y = cbind(RW1,RW2)
y <- ts(y)
# 2. Estimate the model
# Create Y and X
Y <- y[(p + 1):n_obs, ]
X <- matrix(1, nrow(Y), 1)
for (i in 1:p) {
X <- cbind(X, y[(p + 1 - i):(n_obs - i), ])
}
plot(y)
posterior <- Posterior(Y, X, p, N, S)
################### Apply Sign Restriction ########################
sign.restrictions = c(1,1)
Test.Restriction = SignRestrictions(sign.restrictions,posterior)
B0.draws = Test.Restriction$B0.draws
B1.draws = Test.Restriction$B1.draws
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
A=round(apply(A.check,1:2,mean),4)
S =round(apply(S.check,1:2,mean),4)
A
S
######## Narrative sign
narrative.restrictions = c(65:67)
Narrative.Restriction = NarrativeSignRestrictions(sign.restrictions,posterior,narrative.restrictions,Y,X)
B0.draws = Narrative.Restriction$B0.draws
B1.draws = Narrative.Restriction$B1.draws
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
posterior <- Posterior(Y, X, p, N, S)
## Function for drawing posterior distribution , based on lec 12
Posterior <- function(Y, X, p, N, S) {
# MLE
############################################################
A.hat       = solve(t(X)%*%X)%*%t(X)%*%Y
Sigma.hat   = t(Y-X%*%A.hat)%*%(Y-X%*%A.hat)/nrow(Y)
# round(A.hat,3)
# round(Sigma.hat,3)
# round(cov2cor(Sigma.hat),3)
# prior distribution
############################################################
kappa.1     = 1^2
kappa.2     = 100
kappa.3     = 1
A.prior     = matrix(0,nrow(A.hat),ncol(A.hat))
A.prior[2:(N+1),] = kappa.3*diag(N)
V.prior     = diag(c(kappa.2,kappa.1*((1:p)^(-2))%x%rep(1,N)))
S.prior     = diag(diag(Sigma.hat))
nu.prior    = N+1
# normal-inverse Wishard posterior parameters
############################################################
V.bar.inv   = t(X)%*%X + diag(1/diag(V.prior))
V.bar       = solve(V.bar.inv)
A.bar       = V.bar%*%(t(X)%*%Y + diag(1/diag(V.prior))%*%A.prior)
nu.bar      = nrow(Y) + nu.prior
S.bar       = S.prior + t(Y)%*%Y + t(A.prior)%*%diag(1/diag(V.prior))%*%A.prior - t(A.bar)%*%V.bar.inv%*%A.bar
S.bar.inv   = solve(S.bar)
# posterior draws
############################################################
Sigma.posterior   = rWishart(S, df=nu.bar, Sigma=S.bar.inv)
Sigma.posterior   = apply(Sigma.posterior,3,solve)
Sigma.posterior   = array(Sigma.posterior,c(N,N,S))
A.posterior       = array(rnorm(prod(c(dim(A.bar),S))),c(dim(A.bar),S))
B.posterior       = array(NA,c(N,N,S))
L                 = t(chol(V.bar))
B1.posterior = array(NA,c(N,(1+N*p),S))
for (s in 1:S){
cholSigma.s     = chol(Sigma.posterior[,,s])
B.posterior[,,s]= t(cholSigma.s)
A.posterior[,,s]= A.bar + L%*%A.posterior[,,s]%*%cholSigma.s
B1.posterior[,,s] =  B.posterior[,,s]%*%t(A.posterior[,,s])
}
return(list(A.posterior = A.posterior, B.posterior = B.posterior, Sigma.posterior = Sigma.posterior,B1.posterior = B1.posterior))
}
### Impose sign restrictions based on Algorithm 2
# SignRestrictions <- function(sign.restrictions,N,S,p,A.posterior,B.posterior,B1.posterior,Sigma.posterior){
SignRestrictions <- function(sign.restrictions,posterior){
# posterior -   a list - estimation outcome from function Posterior
A.posterior   = posterior$A.posterior
B.posterior = posterior$B.posterior
B1.posterior = posterior$B1.posterior
Sigma.posterior = posterior$Sigma.posterior
S = dim(A.posterior)[3]
N = dim(B.posterior)[1]
p = (dim(B1.posterior)[2]-1)/N
R1            = diag(sign.restrictions)
B0.draws      = array(NA,c(N,N,S))
B1.draws      = array(NA,c(N,(1+N*p),S))
pb = txtProgressBar(min = 0, max = S, initial = 0)
for (s in 1:S){
setTxtProgressBar(pb, s)
B0.tilde <-B.posterior[,,s]
B1.tilde <-  B1.posterior[,,s]
A <- A.posterior[,,s]
Sigma <- Sigma.posterior[,,s]
sign.restrictions.do.not.hold = TRUE
narrative.restriction.do.not.hold = TRUE
i=1
while (sign.restrictions.do.not.hold){
X           = matrix(rnorm(N*N),N,N)
QR          = qr(X, tol = 1e-10)
Q           = qr.Q(QR,complete=TRUE)
R           = qr.R(QR,complete=TRUE)
Q           = t(Q %*% diag(sign(diag(R))))
B0          = Q%*%B0.tilde
B0.inv      = solve(B0)
check       = prod(R1 %*% B0.inv %*% diag(N)[,1] > 0) # Check reponse at time 0
if (check==1){sign.restrictions.do.not.hold=FALSE}
i=i+1
}
B1            = Q%*%B1.tilde
B0.draws[,,s] = B0
B1.draws[,,s] = B1
}
return (list(B0.draws = B0.draws,
B1.draws = B1.draws,
i        = i))
}
NarrativeSignRestrictions <- function(sign.restrictions,posterior,narrative.restrictions,Y,X){
# posterior -   a list - estimation outcome from function Posterior
A.posterior   = posterior$A.posterior
B.posterior = posterior$B.posterior
B1.posterior = posterior$B1.posterior
Sigma.posterior = posterior$Sigma.posterior
YY = Y
XX = X
S = dim(A.posterior)[3]
N = dim(B.posterior)[1]
p = (dim(B1.posterior)[2]-1)/N
R1            = diag(sign.restrictions)
B0.draws      = array(NA,c(N,N,S))
B1.draws      = array(NA,c(N,(1+N*p),S))
pb = txtProgressBar(min = 0, max = S, initial = 0)
for (s in 1:S){
setTxtProgressBar(pb, s)
B0.tilde <-B.posterior[,,s]
B1.tilde <-  B1.posterior[,,s]
A <- A.posterior[,,s]
Sigma <- Sigma.posterior[,,s]
sign.restrictions.do.not.hold = TRUE
narrative.restriction.do.not.hold = TRUE
i=1
while (sign.restrictions.do.not.hold){
X           = matrix(rnorm(N*N),N,N)
QR          = qr(X, tol = 1e-10)
Q           = qr.Q(QR,complete=TRUE)
R           = qr.R(QR,complete=TRUE)
Q           = t(Q %*% diag(sign(diag(R))))
B0          = Q%*%B0.tilde
B0.inv      = solve(B0)
B1          = Q%*%B1.tilde
u = YY %*% t(B0) - XX %*% t(B1)
u= u[,1]
check       = prod(R1 %*% B0.inv %*% diag(N)[,1] > 0  ) # Check reponse at time 0
check_narrative = prod(sign(u[narrative.restrictions]) > 0)
if (check == 1 && check_narrative == 1) {
sign.restrictions.do.not.hold = FALSE
}
i = i + 1
B0.draws[, , s] = B0
B1.draws[, , s] = B1
}
close(pb)
}
return (list(B0.draws = B0.draws,
B1.draws = B1.draws,
i        = i))
}
### Proof that your model can replicate the true parameters of the data-generating process.
# Set parameters
n_obs = 1000
p <- 1
N <- 2
S <- 50000
# 1. Generate artificial data
set.seed(2023) # for reproducibility
cov_matrix <- diag(N)
mean_vector <- rep(0, N)
# Simulate bi-variate Gaussian random walk
RW1 <- arima.sim(model= list(order = c(0, 1, 0)), n=1000, mean=0, sd=1)
RW2 <- arima.sim(model= list(order = c(0, 1, 0)), n=1000, mean=0, sd=1)
y = cbind(RW1,RW2)
y <- ts(y)
# 2. Estimate the model
# Create Y and X
Y <- y[(p + 1):n_obs, ]
X <- matrix(1, nrow(Y), 1)
for (i in 1:p) {
X <- cbind(X, y[(p + 1 - i):(n_obs - i), ])
}
plot(y)
posterior <- Posterior(Y, X, p, N, S)
################### Apply Sign Restriction ########################
sign.restrictions = c(1,1)
Test.Restriction = SignRestrictions(sign.restrictions,posterior)
B0.draws = Test.Restriction$B0.draws
B1.draws = Test.Restriction$B1.draws
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
A=round(apply(A.check,1:2,mean),4)
S =round(apply(S.check,1:2,mean),4)
A
S
######## Narrative sign
narrative.restrictions = c(65:67)
Narrative.Restriction = NarrativeSignRestrictions(sign.restrictions,posterior,narrative.restrictions,Y,X)
B0.draws = Narrative.Restriction$B0.draws
B1.draws = Narrative.Restriction$B1.draws
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
B0.draws = Narrative.Restriction$B0.draws
B1.draws = Narrative.Restriction$B1.draws
B0.draws
B1.draws
s = 2
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
B0.draws[,,2]
B0.draws[,,2]
B0.draws[,,s] %*% t(B0.draws[,,s])
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
for (s in 1:S){
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
B0.draws = Narrative.Restriction$B0.draws
B1.draws = Narrative.Restriction$B1.draws
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
dim(B0.draws)
dim(B1.draws)
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
dim[B0.draws]
dim(B0.draws)
dim(B1.draws)
S.check[,,1]
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
S.check[,,1]
S.check
dim(S.check)
for (s in 1:S){
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
B0.draws = Test.Restriction$B0.draws
B1.draws = Test.Restriction$B1.draws
B0.draws
dim(B0.draws)
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
A=round(apply(A.check,1:2,mean),4)
S =round(apply(S.check,1:2,mean),4)
A
S
s = 1
A.check
A.check(,,s)
A.check[],,s]
A.check[,,s]
###############################################
A.check <- array(NA,c(N+1,N,S))
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
N <- 2
S <- 50000
sign.restrictions = c(1,1)
Test.Restriction = SignRestrictions(sign.restrictions,posterior)
Test.Restriction = SignRestrictions(sign.restrictions,posterior)
B0.draws = Test.Restriction$B0.draws
B1.draws = Test.Restriction$B1.draws
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
A=round(apply(A.check,1:2,mean),4)
S =round(apply(S.check,1:2,mean),4)
A
S
A
S
### Extended model
For this section, I assume the the sign of the structural shocks for period period 65 to period 67 is negative, which is also consistent with the original sign restriction. The parameter values for A and $\sigma$ suggests the function is working well.
```{r, echo=TRUE}
######## Narrative sign
narrative.restrictions = c(65:67)
Narrative.Restriction = NarrativeSignRestrictions(sign.restrictions,posterior,narrative.restrictions,Y,X)
Narrative.Restriction = NarrativeSignRestrictions(sign.restrictions,posterior,narrative.restrictions,Y,X)
B0.draws = Narrative.Restriction$B0.draws
B1.draws = Narrative.Restriction$B1.draws
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
N
###############################################
AN.check <- array(NA,c(N+1,N,S))
SN.check <- array(NA,c(N,N,S))
######## Narrative sign
narrative.restrictions = c(65:67)
Narrative.Restriction = NarrativeSignRestrictions(sign.restrictions,posterior,narrative.restrictions,Y,X)
B0.draws = Narrative.Restriction$B0.draws
B1.draws = Narrative.Restriction$B1.draws
###############################################
AN.check <- array(NA,c(N+1,N,S))
SN.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
SN.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
AN.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
###############################################
AN.check <- array(NA,c(N+1,N,S))
SN.check <- array(NA,c(N,N,S))
s = 1
B0.draws[,,s] %*% t(B0.draws[,,s])
SN[,,1]
SN.check[,,1]
dim(AN.check)
###############################################
AN.check <- array(NA,c(N+1,N,S))
SN.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
SN.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
AN.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
S
### Proof that your model can replicate the true parameters of the data-generating process.
# Set parameters
n_obs = 1000
p <- 1
N <- 2
S <- 50000
# 1. Generate artificial data
set.seed(2023) # for reproducibility
cov_matrix <- diag(N)
mean_vector <- rep(0, N)
# Simulate bi-variate Gaussian random walk
RW1 <- arima.sim(model= list(order = c(0, 1, 0)), n=1000, mean=0, sd=1)
RW2 <- arima.sim(model= list(order = c(0, 1, 0)), n=1000, mean=0, sd=1)
y = cbind(RW1,RW2)
y <- ts(y)
# 2. Estimate the model
# Create Y and X
Y <- y[(p + 1):n_obs, ]
X <- matrix(1, nrow(Y), 1)
for (i in 1:p) {
X <- cbind(X, y[(p + 1 - i):(n_obs - i), ])
}
plot(y)
posterior <- Posterior(Y, X, p, N, S)
################### Apply Sign Restriction ########################
sign.restrictions = c(1,1)
Test.Restriction = SignRestrictions(sign.restrictions,posterior)
B0.draws = Test.Restriction$B0.draws
B1.draws = Test.Restriction$B1.draws
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
Acheck=round(apply(A.check,1:2,mean),4)
Scheck =round(apply(S.check,1:2,mean),4)
Acheck
Scheck
######## Narrative sign
narrative.restrictions = c(65:67)
Narrative.Restriction = NarrativeSignRestrictions(sign.restrictions,posterior,narrative.restrictions,Y,X)
B0.draws = Narrative.Restriction$B0.draws
B1.draws = Narrative.Restriction$B1.draws
###############################################
AN.check <- array(NA,c(N+1,N,S))
SN.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
SN.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
AN.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
AN = round(apply(A.check,1:2,mean),4)
SN = round(apply(S.check,1:2,mean),4)
AN
SN
