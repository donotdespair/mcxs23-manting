B0.draws      = array(NA,c(N,N,S))
B1.draws      = array(NA,c(N,(1+N*p),S))
pb = txtProgressBar(min = 0, max = S, initial = 0)
for (s in 1:S){
setTxtProgressBar(pb, s)
B0.tilde <-B.posterior[,,s]
B1.tilde <-  B1.posterior[,,s]
A <- A.posterior[,,s]
Sigma <- Sigma.posterior[,,s]
sign.restrictions.do.not.hold = TRUE
i=1
while (sign.restrictions.do.not.hold){
X           = matrix(rnorm(N*N),N,N)
QR          = qr(X, tol = 1e-10)
Q           = qr.Q(QR,complete=TRUE)
R           = qr.R(QR,complete=TRUE)
Q           = t(Q %*% diag(sign(diag(R))))
B0          = Q%*%B0.tilde
B0.inv      = solve(B0)
check       = prod(R1 %*% B0.inv %*% diag(N)[,1] > 0) # Check reponse at time 0
if (check==1){sign.restrictions.do.not.hold=FALSE}
i=i+1
}
B1            = Q%*%B1.tilde
B0.draws[,,s] = B0
B1.draws[,,s] = B1
}
return (list(B0.draws = B0.draws,
B1.draws = B1.draws,
i        = i))
}
# Posterios for basic model
#####################################################
#
# p = 4 # time lagt0
# N = 8
# S = 100
#
# # Create Y and X
# y = ts(df[, !names(df) %in% c("Date","nomGDP")])
# Y = y[5:211,]
# X       = matrix(1,nrow(Y),1)
# for (i in 1:p){
#   X     = cbind(X,y[5:211-i,])
# }
# results <- Posterior(Y, X, p, N, S)
#
#
# # Sign.restriction########
# ############################################################
# set.seed(123456)
# sign.restrictions <- c(1,1,1,1,1,1,1,1)
#
#
# ################### Apply Sign Restriction ########################
#
# Basic.Restriction = SignRestrictions(sign.restrictions,results)
#
# B0.draws = Basic.Restriction$B0.draws
# B1.draws = Basic.Restriction$B1.draws
#
#
# ###############################################
#
#
NarrativeSignRestrictions <- function(sign.restrictions,posterior,narrative.restrictions,Y,X){
# posterior -   a list - estimation outcome from function Posterior
A.posterior   = posterior$A.posterior
B.posterior = posterior$B.posterior
B1.posterior = posterior$B1.posterior
Sigma.posterior = posterior$Sigma.posterior
YY = Y
XX = X
S = dim(A.posterior)[3]
N = dim(B.posterior)[1]
p = (dim(B1.posterior)[2]-1)/N
R1            = diag(sign.restrictions)
B0.draws      = array(NA,c(N,N,S))
B1.draws      = array(NA,c(N,(1+N*p),S))
pb = txtProgressBar(min = 0, max = S, initial = 0)
for (s in 1:S){
setTxtProgressBar(pb, s)
B0.tilde <-B.posterior[,,s]
B1.tilde <-  B1.posterior[,,s]
A <- A.posterior[,,s]
Sigma <- Sigma.posterior[,,s]
sign.restrictions.do.not.hold = TRUE
narrative.restriction.do.not.hold = TRUE
i=1
while (sign.restrictions.do.not.hold){
X           = matrix(rnorm(N*N),N,N)
QR          = qr(X, tol = 1e-10)
Q           = qr.Q(QR,complete=TRUE)
R           = qr.R(QR,complete=TRUE)
Q           = t(Q %*% diag(sign(diag(R))))
B0          = Q%*%B0.tilde
B0.inv      = solve(B0)
B1          = Q%*%B1.tilde
u = YY %*% t(B0) - XX %*% t(B1)
u= u[,1]
check       = prod(R1 %*% B0.inv %*% diag(N)[,1] > 0  ) # Check reponse at time 0
check_narrative = prod(sign(u[narrative.restrictions]) > 0)
if (check == 1 && check_narrative == 1) {
sign.restrictions.do.not.hold = FALSE
}
i = i + 1
B0.draws[, , s] = B0
B1.draws[, , s] = B1
}
close(pb)
}
return (list(B0.draws = B0.draws,
B1.draws = B1.draws,
i        = i))
}
### Proof that your model can replicate the true parameters of the data-generating process.
# Set parameters
n_obs = 1000
p <- 1
N <- 2
S <- 50000
# 1. Generate artificial data
set.seed(2023) # for reproducibility
cov_matrix <- diag(N)
mean_vector <- rep(0, N)
# Simulate bi-variate Gaussian random walk
RW1 <- arima.sim(model= list(order = c(0, 1, 0)), n=1000, mean=0, sd=1)
RW2 <- arima.sim(model= list(order = c(0, 1, 0)), n=1000, mean=0, sd=1)
y = cbind(RW1,RW2)
y <- ts(y)
# 2. Estimate the model
# Create Y and X
Y <- y[(p + 1):n_obs, ]
X <- matrix(1, nrow(Y), 1)
for (i in 1:p) {
X <- cbind(X, y[(p + 1 - i):(n_obs - i), ])
}
plot(y)
posterior <- Posterior(Y, X, p, N, S,kappa.1)
################### Apply Sign Restriction ########################
sign.restrictions = c(1,1)
Test.Restriction = SignRestrictions(sign.restrictions,posterior)
B0.draws = Test.Restriction$B0.draws
B1.draws = Test.Restriction$B1.draws
###############################################
A.check <- array(NA,c(N+1,N,S))
S.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
A.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
Acheck=round(apply(A.check,1:2,mean),4)
Scheck =round(apply(S.check,1:2,mean),4)
Acheck
Scheck
######## Narrative sign
narrative.restrictions = c(65:67)
Narrative.Restriction = NarrativeSignRestrictions(sign.restrictions,posterior,narrative.restrictions,Y,X)
B0.draws = Narrative.Restriction$B0.draws
B1.draws = Narrative.Restriction$B1.draws
###############################################
AN.check <- array(NA,c(N+1,N,S))
SN.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert Bo into Sigma
SN.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
AN.check[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
AN = round(apply(A.check,1:2,mean),4)
SN = round(apply(S.check,1:2,mean),4)
AN
SN
#narrative_restrictions <- matrix(NA, nrow = length(df$Date), ncol = 8)
# Government Spending Shock
#narrative_restrictions[c(50, 150), 1] <- 1  # Positive shock at episodes 50 and 150
#narrative_restrictions[100, 1] <- -1        # Negative shock at episode 100
# Apply NarrativeRestrictions function
#test = NarrativeRestrictions(sign.restrictions, N, S, p, Basic_A.posterior, Basic_B.posterior, Basic_B1.posterior, Basic_Sigma.posterior, narrative_restrictions)
library(HDInterval)
set.seed(123456)
########IRF
p = 5 # time lagt0
N = 8
S = 1000
# Create Y and X
######### spending,consumption,realGDP as log form ##################
# dff = df[, names(df) %in% c("consumption","gov_spend","realGDP","M3","CPI","imports","exports")]
# dff = df[, names(df) %in% c("consumption","gov_spend","realGDP","M3","imports","exports")]
# dff = log(dff)
# # dff$realTWI = df$realTWI
# dff$CPI = df$CPI
# y = ts(dff)
# y = ts(df[, !names(df) %in% c("Date","nomGDP","imports","exports")])
# y = ts(df[, !names(df) %in% c("Date","nomGDP","realTWI")])
y = ts(df[, !names(df) %in% c("Date","nomGDP")])
y = log(y)
Y = y[(p+1):211,]
X       = matrix(1,nrow(Y),1)
for (i in 1:p){
X     = cbind(X,y[(p+1):211-i,])
}
results = Posterior(Y,X,p,N,S,1)
Sign_restritions = SignRestrictions(sign.restrictions = c(1,1,1,-1,1,-1,1,1), results)
##################### Results from the Sign_restriction ###################
B0.draws = Sign_restritions$B0.draws
B1.draws = Sign_restritions$B1.draws
##############################################
A.posterior <- array(NA,c(N*p+1,N,S))
B.posterior       = array(NA,c(N,N,S))
S.check <- array(NA,c(N,N,S))
for (s in 1:S){
# convert to into A and B
B  = solve(B0.draws[,,s])
# S.check[,,s] <- B0.draws[,,s] %*% t(B0.draws[,,s])
# cholSigma.s     = chol(S.check[,,s])
# B.posterior[,,s]= t(cholSigma.s)
B.posterior[,,s] = B
A.posterior[,,s] <- t(B1.draws[,,s]) %*% B0.draws[,,s]
}
############################### From the porsterior distribution#########
# A.posterior = results$A.posterior
# B.posterior = results$B.posterior
########https://www.sciencedirect.com/science/article/pii/S0014292121002634#####
h = 8
IRF.posterior     = array(NA,c(N,N,h+1,S))
IRF.inf.posterior = array(NA,c(N,N,S))
FEVD.posterior    = array(NA,c(N,N,h+1,S))
J                 = cbind(diag(N),matrix(0,N,N*(p-1)))
for (s in 1:S){
A.bold          = rbind(t(A.posterior[2:(1+N*p),,s]),cbind(diag(N*(p-1)),matrix(0,N*(p-1),N)))
IRF.inf.posterior[,,s]          = J %*% solve(diag(N*p)-A.bold) %*% t(J) %*% B.posterior[,,s]
A.bold.power    = A.bold
for (i in 1:(h+1)){
if (i==1){
IRF.posterior[,,i,s]        = B.posterior[,,s]
} else {
IRF.posterior[,,i,s]        = J %*% A.bold.power %*% t(J) %*% IRF.posterior[,,i-1,s]
A.bold.power                = A.bold.power %*% A.bold
}
for (n in 1:N){
for (nn in 1:N){
FEVD.posterior[n,nn,i,s]  = sum(IRF.posterior[n,nn,1:i,s]^2)
}
}
FEVD.posterior[,,i,s]         = diag(1/apply(FEVD.posterior[,,i,s],1,sum))%*%FEVD.posterior[,,i,s]
}
}
FEVD.posterior    = 100*FEVD.posterior
# save(IRF.posterior,IRF.inf.posterior, FEVD.posterior, file="irf-fevd-k002.RData")
save(IRF.posterior,IRF.inf.posterior, FEVD.posterior, file="irf-fevd-k1.RData")
# Define colors
mcxs1  = "#05386B"
mcxs2  = "#379683"
mcxs3  = "#5CDB95"
mcxs4  = "#8EE4AF"
mcxs5  = "#EDF5E1"
purple = "#b02442"
mcxs1.rgb   = col2rgb(mcxs1)
mcxs1.shade1= rgb(mcxs1.rgb[1],mcxs1.rgb[2],mcxs1.rgb[3], alpha=120, maxColorValue=255)
mcxs2.rgb   = col2rgb(mcxs2)
mcxs2.shade1= rgb(mcxs2.rgb[1],mcxs2.rgb[2],mcxs2.rgb[3], alpha=120, maxColorValue=255)
# Plots of responses to domestic monetary policy shock
############################################################
load("irf-fevd-k1.RData")
IRFs.k1           = apply(IRF.posterior[,1,,],1:2,mean)
######1st shock is government  spending shock
IRFs.inf.k1       = apply(IRF.inf.posterior[,1,],1,mean)
rownames(IRFs.k1) = colnames(Y)
IRFs.k1.hdi    = apply(IRF.posterior[,1,,],1:2,hdi, credMass=0.68)
hh          = 1:9
par(mfrow=c(3,2), mar=c(4,4.5,2,2),cex.axis=1.5, cex.lab=1.5)
for (n in 1:6){
ylims     = range(IRFs.k1[n,hh],IRFs.k1.hdi[,n,hh])
plot(hh,IRFs.k1[n,hh], type="l", ylim=ylims, axes=FALSE, xlab="", ylab=rownames(IRFs.k1)[n])
if (n==5 | n==6){
axis(1,c(1,2,5,9),c("","1 quarter","1 year","2 years"))
} else {
axis(1,c(1,2,5,9),c("","","",""))
}
axis(2,c(ylims[1],0,ylims[2]),round(c(ylims[1],0,ylims[2]),3))
polygon(c(hh,(h+1):1), c(IRFs.k1.hdi[1,n,hh],IRFs.k1.hdi[2,n,(h+1):1]), col=mcxs1.shade1,border=mcxs1.shade1)
abline(h=0)
lines(hh, IRFs.k1[n,hh],lwd=2,col=mcxs1)
}
# Plots of FEVD of Australian rgdp and p
############################################################
hh <- 1:(h + 1)
fevd.au.rgdp <- apply(FEVD.posterior[2,,,], 1:2, mean)
fevd.au.rgdp <- rbind(rep(0, h + 1), apply(fevd.au.rgdp, 2, cumsum))
fevd.realTWI <- apply(FEVD.posterior[3,,,], 1:2, mean)
fevd.realTWI <- rbind(rep(0, h + 1), apply(fevd.realTWI, 2, cumsum))
colors <- c("deepskyblue1","deepskyblue2","deepskyblue","deepskyblue3","deepskyblue4","dodgerblue",
"maroon1","maroon","maroon2","magenta","maroon3","maroon4")
# Set up the layout for two plots side by side
# par(mfrow = c(3, 2), mar = rep(4, 4), cex.axis = 1, cex.lab = 0.8)
# Plotting fevd-au-gdp-k1
plot(hh, fevd.au.rgdp[1,], type = "n", ylim = c(0, 100), axes = FALSE, xlab = "", ylab = "")
axis(1, hh, c("", "1 quarter", "", "", "1 year", "", "", "", "2 years"))
axis(2, c(0, 50, 100), c("", "FEVD[au.rgdp]", ""))
for (n in 1:N) {
polygon(c(hh, (h + 1):1), c(fevd.au.rgdp[n, hh], fevd.au.rgdp[n + 1, (h + 1):1]), col = colors[n], border = colors[n])
}
axis(4, (0.5 * (fevd.au.rgdp[1:n, 9] + fevd.au.rgdp[2:n+1, 9]))[c(3, 8, 10)], c("us.mps", "", "au.mps"))
# Plotting fevd-au-p-k1
plot(hh, fevd.realTWI[1,], type = "n", ylim = c(0, 100), axes = FALSE, xlab = "", ylab = "")
axis(1, hh, c("", "1 quarter", "", "", "1 year", "", "", "", "2 years"))
axis(2, c(0, 50, 100), c("", "FEVD[realTWI]", ""))
for (n in 1:N) {
polygon(c(hh, (h + 1):1), c(fevd.realTWI[n, hh], fevd.realTWI[n + 1, (h + 1):1]), col = colors[n], border = colors[n])
}
axis(4, (0.5 * (fevd.realTWI[1:n, 9] + fevd.realTWI[2:n+1, 9]))[c(3, 10)], c("us.mps", "au.mps"))
nrow <- 3
ncol <- 3
# Set up the combined plot grid and adjust margins
par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
# ACF plot
for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
acf(df_data_frame[[i]], main = paste("ACF of", variable_name))
}
# Reset the graphical parameters to default
par(mfrow = c(1, 1))
# Set up the combined plot grid
par(mfrow = c(nrow, ncol))
# Run the ACF and PACF functions for each variable and display the plots
for (i in seq_along(df_data_frame )) {
variable_name <- colnames(df_data_frame )[i]
# Set up the combined plot grid again and adjust margins
# par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
#
# # PACF plot
# for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
pacf(df_data_frame[[i]], main = paste("PACF of", variable_name))
}
nrow <- 3
ncol <- 3
# Set up the combined plot grid and adjust margins
par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
# ACF plot
for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
acf(df_data_frame[[i]], main = paste("ACF of", variable_name))
}
# Reset the graphical parameters to default
# par(mfrow = c(1, 1))
# Set up the combined plot grid
par(mfrow = c(nrow, ncol))
# Run the ACF and PACF functions for each variable and display the plots
for (i in seq_along(df_data_frame )) {
variable_name <- colnames(df_data_frame )[i]
# Set up the combined plot grid again and adjust margins
# par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
#
# # PACF plot
# for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
pacf(df_data_frame[[i]], main = paste("PACF of", variable_name))
}
nrow <- 3
ncol <- 3
# Set up the combined plot grid and adjust margins
par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
# ACF plot
for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
acf(df_data_frame[[i]], main = paste("ACF of", variable_name))
}
# Reset the graphical parameters to default
# par(mfrow = c(1, 1))
# Set up the combined plot grid
# par(mfrow = c(nrow, ncol))
# Run the ACF and PACF functions for each variable and display the plots
for (i in seq_along(df_data_frame )) {
variable_name <- colnames(df_data_frame )[i]
# Set up the combined plot grid again and adjust margins
# par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
#
# # PACF plot
# for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
pacf(df_data_frame[[i]], main = paste("PACF of", variable_name))
}
pacf(df_data_frame[[i]], main = paste("PACF of", variable_name))
# Run the ACF and PACF functions for each variable and display the plots
for (i in seq_along(df_data_frame )) {
variable_name <- colnames(df_data_frame )[i]
# Set up the combined plot grid again and adjust margins
# par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
#
# # PACF plot
# for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
pacf(df_data_frame[[i]], main = paste("PACF of", variable_name))
}
nrow <- 3
ncol <- 3
# Set up the combined plot grid and adjust margins
par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
# ACF plot
for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
acf(df_data_frame[[i]], main = paste("ACF of", variable_name))
}
# Reset the graphical parameters to default
# par(mfrow = c(1, 1))
# Set up the combined plot grid
# par(mfrow = c(nrow, ncol))
# Run the ACF and PACF functions for each variable and display the plots
for (i in seq_along(df_data_frame )) {
variable_name <- colnames(df_data_frame )[i]
# Set up the combined plot grid again and adjust margins
# par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
#
# # PACF plot
# for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
pacf(df_data_frame[[i]], main = paste("PACF of", variable_name))
}
nrow <- 3
ncol <- 3
# Set up the combined plot grid and adjust margins
par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
# ACF plot
for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
acf(df_data_frame[[i]], main = paste("ACF of", variable_name))
}
# Reset the graphical parameters to default
# par(mfrow = c(1, 1))
# Set up the combined plot grid
# par(mfrow = c(nrow, ncol))
# Run the ACF and PACF functions for each variable and display the plots
for (i in seq_along(df_data_frame )) {
variable_name <- colnames(df_data_frame )[i]
# Set up the combined plot grid again and adjust margins
# par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
#
# # PACF plot
# for (i in seq_along(df_data_frame)) {
# variable_name <- colnames(df_data_frame)[i]
pacf(df_data_frame[[i]], main = paste("PACF of", variable_name))
}
# ACF plot
for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
acf(df_data_frame[[i]], main = paste("ACF of", variable_name))
}
for (i in seq_along(df_data_frame )) {
variable_name <- colnames(df_data_frame )[i]
# Set up the combined plot grid again and adjust margins
# par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
#
# # PACF plot
# for (i in seq_along(df_data_frame)) {
# variable_name <- colnames(df_data_frame)[i]
pacf(df_data_frame[[i]], main = paste("PACF of", variable_name))
}
nrow <- 3
ncol <- 3
# Set up the combined plot grid and adjust margins
par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
# ACF plot
for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
acf(df_data_frame[[i]], main = paste("ACF of", variable_name))
}
# Reset the graphical parameters to default
# par(mfrow = c(1, 1))
# Set up the combined plot grid
# par(mfrow = c(nrow, ncol))
# Run the ACF and PACF functions for each variable and display the plots
# ACF plot
for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
acf(df_data_frame[[i]], main = paste("ACF of", variable_name))
}
# ACF plot
for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
acf(df_data_frame[[i]], main = paste("ACF of", variable_name))
}
nrow <- 3
ncol <- 3
# Set up the combined plot grid and adjust margins
par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
# ACF plot
for (i in seq_along(df_data_frame)) {
variable_name <- colnames(df_data_frame)[i]
acf(df_data_frame[[i]], main = paste("ACF of", variable_name))
}
par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
par(mfrow = c(nrow, ncol), mar = c(3, 3, 1, 1))
nrow <- 3
ncol <- 3
# Set up the combined plot grid
par(mfrow = c(nrow, ncol))
# Run the ACF and PACF functions for each variable and display the plots
for (i in seq_along(df_data_frame )) {
variable_name <- colnames(df_data_frame )[i]
# ACF plot
acf(df_data_frame [[i]], main = paste("ACF of", variable_name))
}
# Reset the graphical parameters to default
par(mfrow = c(nrow, ncol))
# PACF plot
for (i in seq_along(df_data_frame )) {
variable_name <- colnames(df_data_frame )[i]
# PACF plot
pacf(df_data_frame [[i]], main = paste("PACF of", variable_name))
}
